import random


# 定义城市坐标和距离矩阵
cities = {
    "city1":  (41, 94),
    "city2":  (37, 84),
    "city3":  (54, 67),
    "city4":  (25, 62),
    "city5":  (7, 64),
    "city6":  (2, 99),
    "city7":  (68, 58),
    "city8":  (71, 44),
    "city9":  (54, 62),
    "city10": (83, 69)
}

# 定义城市之间的航空运输距离和铁路运输距离（以公里为单位）以及每单位的运输成本
transport_distances = {
    ("city1", "city2"): {"air": 150, "rail": 100},
    ("city1", "city3"): {"air": 342, "rail": 595},
    ("city1", "city4"): {"air": 0, "rail": 822},
    ("city2", "city3"): {"air": 512, "rail": 757},
    ("city2", "city6"): {"air": 373, "rail": 456},
    ("city3", "city4"): {"air": 0, "rail": 331},
    ("city3", "city5"): {"air": 726, "rail": 529},
    ("city3", "city6"): {"air": 0, "rail": 244},
    ("city3", "city7"): {"air": 334, "rail": 417},
    ("city4", "city5"): {"air": 271, "rail": 349},
    ("city4", "city7"): {"air": 482, "rail": 351},
    ("city4", "city8"): {"air": 610, "rail": 450},
    ("city4", "city9"): {"air": 407, "rail": 422},
    ("city6", "city7"): {"air": 339, "rail": 313},
    ("city6", "city10"): {"air": 0, "rail": 613},
    ("city7", "city8"): {"air": 239, "rail": 237},
    ("city7", "city10"): {"air": 0, "rail": 377},
    ("city8", "city9"): {"air": 335, "rail": 324},
    ("city9", "city10"): {"air":450, "rail": 384},
}


# 定义一些全局变量
air_transport_cost_per_km = 20
rail_transport_cost_per_km = 8
air_speed_km_per_hour = 120
rail_speed_km_per_hour = 80

# 创建城市列表
cities_list = list(set(city for city_pair in transport_distances.keys() for city in city_pair if city not in ["city1", "city10"]))

# 获取两个城市之间的运输信息
def get_transport_info(city1, city2):
    if (city1, city2) in transport_distances:
        air_distance = transport_distances[(city1, city2)].get("air", 0)
        rail_distance = transport_distances[(city1, city2)].get("rail", 0)
        if air_distance > 0:
            time = air_distance / air_speed_km_per_hour
            cost = air_distance * air_transport_cost_per_km
            return "air", air_distance, time, cost
        elif rail_distance > 0:
            time = rail_distance / rail_speed_km_per_hour
            cost = rail_distance * rail_transport_cost_per_km
            return "rail", rail_distance, time, cost
    return "none", 0, 0, 0

# 检查路径的每个段是否有效
def is_valid_segment(segment):
    _, _, time, cost = get_transport_info(segment[0], segment[1])
    return time != 0 and cost != 0

# 深度优先搜索生成有效路径
def dfs_find_valid_path(current_city, path, visited):
    if current_city == "city10":
        return path

    for next_city in cities_list + ["city10"]:
        if next_city not in visited and is_valid_segment((current_city, next_city)):
            new_path = path + [(current_city, next_city)]
            new_visited = visited | {next_city}
            result = dfs_find_valid_path(next_city, new_path, new_visited)
            if result:
                return result
    return None


# 生成有效的个体
def generate_individual():
    return dfs_find_valid_path("city1", [], {"city1"})

# 计算路径的总距离、成本和时间
def calculate_total_distance_cost_and_time(segments):
    total_distance = total_cost = total_time = 0
    for segment in segments:
        _, distance, time, cost = get_transport_info(segment[0], segment[1])
        total_distance += distance
        total_cost += cost
        total_time += time
    return total_distance, total_cost, total_time


def calculate_fitness(path):
    """
    计算给定路径的适应度，考虑时间和成本的权重。
    适应度越高，路径越优。
    """
    total_distance, total_cost, total_time = calculate_total_distance_cost_and_time(path)
    if total_distance == float('inf') or total_cost == 0 or total_time == 0:
        return 0

    # 适应度定义为成本和时间的加权组合的倒数
    fitness = 1 / (cost_weight * total_cost + time_weight * total_time)
    return fitness



# 定义麻雀类
class Sparrow:
    def __init__(self, path):
        if path:
            self.path = path
            self.fitness = self.calculate_fitness(path)
        else:
            self.path = None
            self.fitness = 0


    def calculate_fitness(self, path):
        total_distance, total_cost, total_time = calculate_total_distance_cost_and_time(path)
        if total_distance == float('inf') or total_cost == 0 or total_time == 0:
            return 0
        return 1 / (cost_weight * total_cost + time_weight * total_time)

# 生成初始种群
def generate_individual():
    path = ["city1"]
    current_city = "city1"
    while current_city != "city10":
        next_cities = [city for city in cities if (current_city, city) in transport_distances]
        if not next_cities:
            # 如果没有有效的下一个城市，重新开始
            path = ["city1"]
            current_city = "city1"
            continue
        next_city = random.choice(next_cities)
        path.append(next_city)
        current_city = next_city
    path_segments = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
    return path_segments

# 生成初始种群
def generate_initial_population(size):
    population = []
    for _ in range(size):
        individual = generate_individual()
        if individual:  # 确保个体不为空
            population.append(Sparrow(individual))
    return population

# 更新麻雀位置的函数
def update_sparrow(sparrow, leader_sparrow):
    if sparrow.path is None or leader_sparrow.path is None:
        return sparrow

    new_path = sparrow.path[:]
    for i in range(len(new_path)):
        if random.random() < indpb:
            swap_with = random.randint(0, len(new_path) - 1)
            new_path[i], new_path[swap_with] = new_path[swap_with], new_path[i]

        # 根据警戒值和探索/开发因子调整位置
        if random.random() < alertness_value:
            if random.random() < exploration_factor:
                # 执行探索操作
                pass  # 可以添加特定的探索逻辑
            else:
                # 执行开发操作
                pass  # 可以添加特定的开发逻辑

        # 尝试与领头麻雀的路径对齐
        if random.random() < alignment_factor:
            align_point = random.randint(0, min(len(new_path), len(leader_sparrow.path)) - 1)
            new_path = leader_sparrow.path[:align_point] + new_path[align_point:]

        new_sparrow = Sparrow(new_path)
        return new_sparrow if new_sparrow.fitness > sparrow.fitness else sparrow


# 麻雀算法主函数
# 定义麻雀算法主函数
def sparrow_search(population_size, num_generations):
    # 初始化种群
    population = generate_initial_population(population_size)

    for _ in range(num_generations):
        # 评估所有麻雀的适应度
        for sparrow in population:
            sparrow.fitness = calculate_fitness(sparrow.path)

        # 选择领头麻雀
        leader_sparrow = max(population, key=lambda x: x.fitness)

        # 更新其他麻雀的位置
        for sparrow in population:
            if sparrow != leader_sparrow:
                sparrow = update_sparrow(sparrow, leader_sparrow)

    return max(population, key=lambda x: x.fitness)

# 定义参数
time_weight = 1.8  # 运输时间的权重。这个值决定了在计算适应度时运输时间的相对重要性。较高的权重意味着时间对适应度的影响更大。
cost_weight = 1.0  # 运输成本的权重。这个值决定了在计算适应度时运输成本的相对重要性。较高的权重意味着成本对适应度的影响更大。
population_size = 200  # 种群大小。这个值指定了算法中种群的个体数量。种群大小决定了算法搜索解空间的能力。
num_generations = 200  # 迭代代数。这个值指定了算法运行的代数，即进行多少轮选择、交叉和变异操作。
indpb = 0.2  # 个体变异概率。这个值指定了个体中每个部分发生变异的概率，用于引入种群的多样性。
leader_sparrow_ratio = 0.1  # 领头麻雀的比例。在麻雀算法中，某些麻雀被视为领头麻雀，它们对其他麻雀的位置有影响。这个比例确定了多少麻雀被视为领头麻雀。
alertness_value = 0.2       # 警戒值。这个值用于决定麻雀是否应该对环境变化作出反应。较低的警戒值意味着麻雀更容易对环境变化做出反应。
exploration_factor = 0.3    # 探索因子。这个值决定了麻雀进行探索行为的概率。在麻雀算法中，探索是指尝试寻找新的、未知的解决方案。
exploitation_factor = 0.8   # 开发因子。这个值决定了麻雀进行开发行为的概率。在麻雀算法中，开发是指在已知的解决方案周围寻找更优解。
alignment_factor = 0.3  # 添加与领头麻雀对齐的概率

# 运行麻雀算法
best_sparrow = sparrow_search(population_size, num_generations)

# 打印最佳路径
if best_sparrow.path:
    print("找到有效路径:")
    for segment in best_sparrow.path:
        city1, city2 = segment
        mode, distance, time, _ = get_transport_info(city1, city2)
        if mode != "none":
            print(f"从 {city1} 到 {city2}：方式 - {mode}, 距离 - {distance} km, 时间 - {time:.2f} 小时")

    total_distance, total_cost, total_time = calculate_total_distance_cost_and_time(best_sparrow.path)
    print(f"\n总运输距离：{total_distance} km")
    print(f"总运输成本：{total_cost:.2f} 元")
    print(f"总运输时间：{total_time:.2f} 小时")
else:
    print("未找到有效路径")
